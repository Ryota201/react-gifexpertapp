{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","props","categories","ReactDOM","render","document","getElementById"],"mappings":"oMAIaA,EAAc,SAAC,GAA0B,IAAvBC,EAAsB,EAAtBA,cAM3B,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KA0CA,OACQ,sBAAMC,SArBO,SAACC,GAElBA,EAAEC,iBAEGJ,EAAWK,OAAOC,OAAO,IAK1BR,GAAe,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OAGvCN,EAAc,MASd,SACI,uBACIO,KAAK,OACLC,MAAQT,EACRU,SAjCU,SAAEP,GAIzBF,EAAeE,EAAEQ,OAAOF,a,sCCvBlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbC,EAFa,iDAEoCC,UAAWH,GAF/C,+DAIAI,MAAOF,GAJP,cAIbG,EAJa,gBAKIA,EAAKC,OALT,uBAKXC,EALW,EAKXA,KAEFC,EAAOD,EAAKE,KAAK,SAAAC,GAAS,IAAD,EAI3B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAfvB,kBAmBZM,GAnBY,4CAAH,sDCQLO,EAXY,SAAC,GAAsB,IAAnBH,EAAkB,EAAlBA,MAAOV,EAAW,EAAXA,IAGlC,OACI,sBAAKc,UAAU,yCAAf,UACI,qBAAKC,IAAMf,EAAMgB,IAAMN,IACvB,kCAAMA,EAAN,WCFCO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SActB,ECZwB,SAAEA,GAK1B,MAA0Bd,mBAAS,CAC/BqB,KAAO,GACPa,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAuCA,OAnBAC,qBAAW,WAMPxB,EAASC,GACRwB,MAAM,SAAAC,GACHH,EAAS,CACLf,KAAMkB,EAENL,SAAU,SAInB,CAACpB,IAIGqB,EDhC2BK,CAAc1B,GAAnCa,EAAb,EAAQN,KAAca,EAAtB,EAAsBA,QAEtB,OAEI,cADA,CACA,sBACA,qBAAKJ,UAAU,oCAAf,cAAsDhB,EAAtD,OAKEoB,GAAW,mBAAGJ,UAAU,mCAAb,qBAEb,qBAAKA,UAAU,YAAf,SAEQH,EAAOJ,KAAK,SAAAC,GAAG,OACX,cAAC,EAAD,eAKSA,GAJEA,EAAIC,aEiBpBgB,EA/CM,SAAAC,GAGjB,MAAoC1C,mBAAS,CAAC,gBAA9C,mBAAO2C,EAAP,KAAmB5C,EAAnB,KAaA,OACI,qCACI,8CACA,cAAC,EAAD,CAAaA,cAAgBA,IAC7B,uBAGA,6BAMQ4C,EAAWpB,KAAK,SAAAT,GAAQ,OACpB,cAAC,EAAD,CAEIA,SAAYA,GADJA,Y,MC/BpC8B,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.68427860.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport const AddCategory = ( { setCategories } )  => {\r\n\r\n    \r\n    /*const [inputValue, setInputValue] = useState() -> de está forma el estado es undefined,\r\n    por consecuencia si queremos el input value sea un string vacio que así sea.\r\n    */\r\n    const [inputValue, setInputValue] = useState('')\r\n\r\n\r\n    /*La caja de texto(input) debe tener algún tipo de estado, \r\n    porque necesito saber lo que la persona esta escribiendo.\r\n\r\n    El inputValue por defecto tiene el valor de Hola Mundo\r\n    */\r\n\r\n    \r\n    /*Necesitamos extraer el nuevo valor(que esta dentro del target),\r\n    ese valor lo extraemos con una constante, recibimos el evento  en los\r\n    parámetros de la función de flecha    \r\n    */\r\n    const handleInputChange = ( e ) => {\r\n       /*Tenemos que tomar el target value y llamar el setInputValue,\r\n       de esta manera podemos escribir todo lo que queramos\r\n       */\r\n       setInputValue( e.target.value );\r\n    }\r\n\r\n    /*Recibimos el event porque voy a colocarselo a algo(form)*/\r\n    const handleSubmit = (e) => {\r\n        /*Para prevenir el comportamiento por defecto del formulario(actualizar la página)*/\r\n        e.preventDefault();\r\n\r\n        if ( inputValue.trim().length>2 ){\r\n            //console.log('Submit hecho')\r\n            /*setCategories se puede llamar con un callback que puede ser añadido y lo único \r\n            que tenemos que hacer es pasarle el inputValue como 2da parámetro\r\n            */\r\n            setCategories( cats => [inputValue, ...cats ] );//1ero el valor que se ingresa en el input, luego los valores antiguos\r\n            /*Borramos el valor para que no haga un doble posteo, mandando un setValue\r\n            comoo vacio*/\r\n            setInputValue('');\r\n        }\r\n    }\r\n\r\n   /*El formulario por sí mismo, es el que agrupa todos los elementos o los inputs\r\n    que yo podría tener dentro del mismo, por lo cual, no es necesario tener <> </> \r\n    en el caso de que tengamos un elemento que agrupe todo lo demás.\r\n   */\r\n    return (\r\n            <form onSubmit={ handleSubmit }>\r\n                <input \r\n                    type=\"text\"   \r\n                    value={ inputValue } //por consecuencia este valor es undefined(línea 42)\r\n                    onChange={ handleInputChange }\r\n                />\r\n            </form>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    //func(función) es requerida\r\n    setCategories : PropTypes.func.isRequired\r\n}\r\n","\r\n/*Necesitamos la categoría, por lo cual, hay que mandarla como argumento.\r\nCómo es async esta función directamente no es que regrese los gifs, regresa\r\nuna promesa que resuelve la colección de mis imágenes\r\n*/\r\nexport const getGifs = async( category ) => {\r\n    //el h3{category} lo mandamos al api por eso aparecen las imágenes que escribimos\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=AjCIRll15uGzfgOAFZlDvUtlSUxJabj7`\r\n    /*Llamamos al endpoint*/\r\n    const resp = await fetch( url );\r\n    const { data } = await resp.json();\r\n\r\n    const gifs = data.map( img =>  {\r\n        /*El return va a hacer lo que va a transformar cada uno de los elementos del arreglo(img),\r\n        retornando un nuevo objeto solo con la información que a mi me interesa\r\n        */\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            // img.images?, preguntamos si viene las imágenes, entonces que lo utilice \r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    })\r\n\r\n    return gifs;\r\n\r\n}","import React from 'react'\r\n\r\nexport const GifGridItem = ( { title, url } ) => {\r\n\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\"  >\r\n            <img src={ url } alt={ title } ></img>\r\n            <p> { title } </p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default GifGridItem\r\n","//useEffect, me va a permitir a mi poder ejecutar cierto código de manera condicional\r\nimport React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport GifGridItem from './GifGridItem';\r\n\r\n/*Recibimos la categoría como argumento*/\r\nexport const GifGrid = ({ category }) => {\r\n\r\n\r\n    /*Importamos el custom hooks, almacenamos el objeto.\r\n    Para renombrar un argumento en la desestructuración, \r\n    ponemos data:images(nombre que le queremos dar).\r\n\r\n    Para recapitular simplemente llamamos al custom hooks useFetchGifs,\r\n    el cual hace el trabajo pesado, donde se hace el efecto para que se\r\n    dispare solo cuando cambia la categoría, hace la petición http, \r\n    tenemos la imágenes, se pone el timeOut intencional para ponerlo un \r\n    poco más lento y cuando ya se tiene la data, se llama el setState  \r\n    cambiando la información.\r\n    */\r\n    const { data:images,  loading } = useFetchGifs( category );\r\n\r\n    return (\r\n        //fragment\r\n        <>\r\n        <h3  className=\"animate__animated animate__fadeIn\"> { category } </h3>\r\n\r\n        {/*Con el operador and si el loading es true se evalua el parráfo, \r\n        si el 1ero nuestro entonces no hace nada\r\n        */}\r\n        { loading && <p className=\"animate__animated animate__flash\" >Loading</p> }\r\n        \r\n        <div className=\"card-grid\">\r\n            {\r\n                images.map( img => (\r\n                    <GifGridItem \r\n                        key= { img.id }   \r\n                        /*De esta manera estoy mandando cada una de las propiedades de las imágenes,\r\n                        como una propiedad independiente\r\n                        */                      \r\n                        { ...img }\r\n                    />\r\n                ))\r\n            }\r\n        </div>\r\n        </>\r\n    )\r\n}\r\n","import { useState } from 'react';\r\nimport { useEffect } from 'react/cjs/react.development';\r\nimport { getGifs  } from '../helpers/getGifs';\r\n\r\n\r\n/*La categoría mandanda en GifGrid cae en los parámetros como si fueran \r\nprops, pero acá sería category\r\n*/\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    /*El estado inicial va a ser un objeto que va a tener un arreglo que va\r\n    a ser vacío, va a ser una data\r\n    */\r\n    const [state, setState] = useState({\r\n        data : [],\r\n        loading: true\r\n    });\r\n\r\n    /* Le ponemos efecto al custom hooks\r\n    Colocamos como 2do argumento un arreglo vacío para que solo lo ejecuta una vez.\r\n    \r\n    Después de recibir la categoría como parámetro puedo evaluar únicamente este \r\n    efecto, cuando la categoría cambia, es decir, la 1era vez que va a cambiar y ahí \r\n    se va a disparar : }, [category])\r\n\r\n\r\n    Los efectos no pueden ser async por que esperan algo síncronico, pero perfectamente\r\n    se puede utilizar un then y  tener las imágenes en una función de flecha-->\r\n        getGifs( category )\r\n            .then( imgs => {\r\n                \r\n            })\r\n    */\r\n    useEffect( () => {\r\n        /*Ejecutamos el cuerpo de la petición http para extraer las imágenes.\r\n        En los paréntesis le mandamos la categoría. Cómo no tenemos la categoría en\r\n        ningún lugar, por consecuencia puedo mandarle como argumento a mi \r\n        useFetchGifts la categoría--> const { loading } = useFetchGifs( category );\r\n        */\r\n        getGifs( category )\r\n        .then( imgs => {\r\n            setState({\r\n                data: imgs,\r\n                //false pq ya cargaron las imágenes\r\n                loading : false\r\n            })\r\n        })\r\n\r\n    }, [category])\r\n\r\n\r\n\r\n    return state; //el state es esto: { data:[] , loading: true }\r\n\r\n}\r\n","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n//import PropTypes from 'prop-types'\r\n\r\n//Componente Padre\r\nconst GifExpertApp = props => {\r\n\r\n    //const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n    const [categories, setCategories] = useState(['Dragon Ball']);    \r\n\r\n    /*\r\n    const handleAdd = () =>{\r\n        //setCategories([ 'HunterXHunter', ...categories ]);\r\n        setCategories( cats => [...cats, 'HunterXHunter'] );\r\n    }\r\n    */\r\n\r\n    /*A nuestro AddCategory vamos a pasarle una función,\r\n    en este caso es el setCategories y mandamos la referencia\r\n    al setCategories = { setCategories }\r\n    */\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories={ setCategories } />\r\n            <hr/>\r\n\r\n\r\n            <ol>\r\n                { \r\n                    /*map me sirve para transformar cada uno de los elementos que están dentro de su arreglo.\r\n                    Esto es como un pequeño ciclo. El map recibe 2 argumentos por defecto, el 1ero es la categoría,\r\n                    el argumento del arreglo, el 2do es el índice.\r\n                    */\r\n                    categories.map( category => (\r\n                        <GifGrid \r\n                            key = { category }\r\n                            category={  category }\r\n                        />\r\n                    )) /*La key sirve para react sepa cual es el elemento que esta iterando */\r\n                    \r\n                }\r\n            </ol>\r\n        </>\r\n    )\r\n}\r\n\r\n/*\r\nGifExpertApp.propTypes = {\r\n\r\n}\r\n*/\r\nexport default GifExpertApp\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\n\nReactDOM.render(\n  <GifExpertApp />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}